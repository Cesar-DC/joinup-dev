<?php

/**
 * @file
 * Module handling notifications in joinup.
 */

use Drupal\Core\Entity\ContentEntityInterface;
use \Drupal\Core\Entity\EntityInterface;
use Drupal\message\Entity\Message;
use Drupal\og\Entity\OgMembership;
use Drupal\user\Entity\Role;

/**
 * Implements hook_entity_predelete().
 *
 * Handles the notifications for the entity types rdf_entity and node the same
 * way as the WorkflowTransitionEventSubscriber does but since we do not have a
 * transition when an entity is deleted, there is no event fired.
 * Thus, this is handled separately.
 *
 * This notification functionality is currently applying if the two following
 * criteria are met:
 *  - The entity has a state field and the state is 'deletion_request'.
 *  - There is configuration set for the entity type and the bundle.
 *
 * @see \Drupal\joinup_notification\config\schema\joinup_notification.schema.yml
 */
function joinup_notification_entity_predelete(EntityInterface $entity) {
  $entity_type = $entity->getEntityTypeId();
  $bundle = $entity->bundle();
  if (!($entity instanceof ContentEntityInterface) || !in_array($entity->getEntityTypeId(), ['rdf_entity', 'node'])) {
    return;
  }

  $field_definitions = array_filter(\Drupal::entityManager()->getFieldDefinitions($entity_type, $bundle), function ($field_definition) {
    return $field_definition->getType() == 'state';
  });

  if (empty($field_definitions)) {
    return;
  }

  $field_definition = array_pop($field_definitions);
  $state_field = $entity->{$field_definition->getName()}->first();
  if (empty($state_field->value) || $state_field->value != 'deletion_request') {
    return;
  }

  $configuration = \Drupal::config('joinup_notification.settings')->get('delete_notifications');
  if (empty($configuration[$entity_type][$bundle])) {
    return;
  }
  foreach ($configuration[$entity_type][$bundle] as $role_id => $messages) {
    $role = Role::load($role_id);
    if (!empty($role)) {
      $user_ids = \Drupal::service('entity.manager')->getStorage('user')->getQuery()
        ->condition('user_role', $role_id)
        ->execute();
      $recipients = $user_ids;
    }
    else {
      $membership_query = \Drupal::service('entity.manager')->getStorage('og_membership')->getQuery()
        ->condition('state', 'active')
        ->condition('entity_id', $entity->id());
      $memberships_ids = $membership_query->execute();
      $memberships = OgMembership::loadMultiple($memberships_ids);
      $memberships = array_filter($memberships, function ($membership) use ($role_id) {
        $roles = $membership->getRoles();
        $role_ids = array_keys($roles);
        return in_array($role_id, $role_ids);
      });
      // We need to handle possible broken relationships or memberships that
      // are not removed yet.
      $user_ids = array_map(function ($membership) {
        $user = $membership->getUser();
        return empty($user) ? NULL : $user->id();
      }, $memberships);
      $recipients = array_filter($user_ids);
    }

    /** @var OgMembership $membership */
    foreach ($recipients as $user_id) {
      foreach ($messages as $message_id) {
        // Create the actual message and save it to the db.
        $message = Message::create([
          'template' => $message_id,
          'uid' => $user_id,
          'field_message_content' => $entity->id(),
        ]);
        $message->save();
        // Send the saved message as an e-mail.
        \Drupal::service('message_notify.sender')->send($message, [], 'email');
      }
    }
  }
}
