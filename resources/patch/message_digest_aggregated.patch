diff --git a/message_digest.behat.inc b/message_digest.behat.inc
new file mode 100644
index 0000000..f5482ed
--- /dev/null
+++ b/message_digest.behat.inc
@@ -0,0 +1,181 @@
+<?php
+
+/**
+ * @file
+ * Contains \MessageDigestSubContext.
+ */
+
+use Behat\Gherkin\Node\TableNode;
+use Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException;
+use Drupal\DrupalExtension\Context\DrupalSubContextBase;
+use Drupal\DrupalExtension\Context\DrupalSubContextInterface;
+use Drupal\message_digest\Traits\MessageDigestTrait;
+
+/**
+ * Behat step definitions for the Message Digest module.
+ */
+class MessageDigestSubContext extends DrupalSubContextBase implements DrupalSubContextInterface {
+
+  use MessageDigestTrait;
+
+  /**
+   * Checks that the digest for a user contains a certain message.
+   *
+   * @param \Behat\Gherkin\Node\TableNode $table
+   *   A table containing the expected content of the different view modes for
+   *   the message. Example:
+   *   | mail_subject | The content titled "My content" has been deleted       |
+   *   | mail_body    | The "My content" page was deleted by an administrator. |
+   * @param string $interval
+   *   The digest interval, e.g. 'daily' or 'weekly'.
+   * @param string $username
+   *   The name of the user for which the message is intended.
+   * @param string $label
+   *   Optional label of an entity that is related to the message.
+   * @param string $entity_type
+   *   Optional entity type of an entity that is related to the message.
+   *
+   * @Then the :interval digest for :username should contain the following message for the :label :entity_type:
+   * @Then the :interval digest for :username should contain the following message:
+   */
+  public function assertDigestContains(TableNode $table, $interval, $username, $label = NULL, $entity_type = NULL) {
+    // Check that the passed table contains valid view modes.
+    $rows = $table->getRowsHash();
+    $view_modes = array_keys($rows);
+    $notifier = $this->getMessageDigestNotifierForInterval($interval);
+    $this->assertNotifierViewModes($notifier, $view_modes);
+
+    $user = user_load_by_name($username);
+    $messages = $this->getUserMessagesByNotifier($notifier, $user->id(), $entity_type, $label);
+    if (empty($messages)) {
+      throw new \RuntimeException("The $interval digest for $username does not contain any messages related to the '$label' $entity_type.");
+    }
+
+    foreach ($messages as $message) {
+      $found_view_modes = [];
+      foreach ($rows as $view_mode => $expected_content) {
+        $actual_content = $this->getRenderedMessage($message, $view_mode);
+        if (strpos($actual_content, $expected_content) !== FALSE) {
+          $found_view_modes[] = $view_mode;
+        }
+      }
+      if (empty(array_diff($view_modes, $found_view_modes))) {
+        // We found the message.
+        return;
+      }
+    }
+    $exception_message = !empty($entity_type) && !empty($label) ? "The expected message for the '$label' $entity_type was not found in the $interval digest for $username." : "The expected message was not found in the $interval digest for $username.";
+    throw new \RuntimeException($exception_message);
+  }
+
+  /**
+   * Checks that the digest for a user does not contain a certain message.
+   *
+   * @param \Behat\Gherkin\Node\TableNode $table
+   *   A table containing the expected content of the different view modes for
+   *   the message that should not be present. Example:
+   *   | mail_subject | The content titled "My content" has been deleted       |
+   *   | mail_body    | The "My content" page was deleted by an administrator. |
+   * @param string $interval
+   *   The digest interval, e.g. 'daily' or 'weekly'.
+   * @param string $username
+   *   The name of the user for which the message is intended.
+   * @param string $label
+   *   Optional label of an entity that is related to the message.
+   * @param string $entity_type
+   *   Optional entity type of an entity that is related to the message.
+   *
+   * @Then the :interval digest for :username should not contain the following message for the :label :entity_type:
+   * @Then the :interval digest for :username should not contain the following message:
+   */
+  public function assertDigestNotContains(TableNode $table, $interval, $username, $label = NULL, $entity_type = NULL) {
+    // Check that the passed table contains valid view modes.
+    $rows = $table->getRowsHash();
+    $view_modes = array_keys($rows);
+    $notifier = $this->getMessageDigestNotifierForInterval($interval);
+    $this->assertNotifierViewModes($notifier, $view_modes);
+
+    $user = user_load_by_name($username);
+    $messages = $this->getUserMessagesByNotifier($notifier, $user->id(), $entity_type, $label);
+    foreach ($messages as $message) {
+      $found_view_modes = [];
+      foreach ($rows as $view_mode => $expected_content) {
+        $actual_content = $this->getRenderedMessage($message, $view_mode);
+        if (strpos($actual_content, $expected_content) !== FALSE) {
+          $found_view_modes[] = $view_mode;
+        }
+      }
+      if (empty(array_diff($view_modes, $found_view_modes))) {
+        // We found the message.
+        $exception_message = !empty($entity_type) && !empty($label) ? "The message for the '$label' $entity_type was unexpectedly found in the $interval digest for $username." : "The message was unexpectedly found in the $interval digest for $username.";
+        throw new \RuntimeException($exception_message);
+      }
+    }
+  }
+
+  /**
+   * Delivers all message digests.
+   *
+   * @Given all message digests have been delivered
+   *
+   * @throws \Exception
+   *   Thrown in case an error occurred while running the cron job.
+   */
+  public function deliverAllDigests() {
+    $this->expireDigestMessages();
+    do {
+      $this->expireMessageDigestNotifiers();
+      $this->getDriver()->runCron();
+    }
+    while ($this->countAllUndeliveredDigestMessages());
+  }
+
+  /**
+   * Returns the entity with the given type, bundle and label.
+   *
+   * If multiple entities have the same label then the first one is returned.
+   *
+   * @param string $entity_type
+   *   The entity type to check.
+   * @param string $label
+   *   The label to check.
+   * @param string $bundle
+   *   Optional bundle to check. If omitted, the entity can be of any bundle.
+   *
+   * @return \Drupal\Core\Entity\EntityInterface
+   *   The requested entity.
+   *
+   * @throws \RuntimeException
+   *   Thrown when an entity with the given type, label and bundle does not
+   *   exist.
+   */
+  protected function getEntityByLabel($entity_type, $label, $bundle = NULL) {
+    $entity_manager = \Drupal::entityTypeManager();
+    try {
+      $storage = $entity_manager->getStorage($entity_type);
+    }
+    catch (InvalidPluginDefinitionException $e) {
+      throw new \RuntimeException("Storage for entity type '$entity_type' not found", NULL, $e);
+    }
+    $entity = $entity_manager->getDefinition($entity_type);
+
+    $query = $storage->getQuery()
+      ->condition($entity->getKey('label'), $label)
+      ->range(0, 1);
+
+    // Optionally filter by bundle.
+    if ($bundle) {
+      $query->condition($entity->getKey('bundle'), $bundle);
+    }
+
+    $result = $query->execute();
+
+    if ($result) {
+      $result = reset($result);
+      return $storage->load($result);
+    }
+
+    throw new \RuntimeException("The entity with label '$label' was not found.");
+  }
+
+}
diff --git a/message_digest.module b/message_digest.module
index 301e412..cf1f56f 100644
--- a/message_digest.module
+++ b/message_digest.module
@@ -5,6 +5,8 @@
  * Hook implementations for the Message Digest module.
  */
 
+use Drupal\Core\Database\Database;
+use Drupal\Core\Entity\EntityInterface;
 use Drupal\Core\Render\Element;
 
 /**
@@ -13,6 +15,7 @@ use Drupal\Core\Render\Element;
  * Aggregate, format and and queue digests for sending.
  */
 function message_digest_cron() {
+  /** @var \Drupal\message_digest\DigestManagerInterface $digest_manager */
   $digest_manager = \Drupal::service('message_digest.manager');
 
   // Process message digests.
@@ -81,3 +84,26 @@ function template_preprocess_message_digest(array &$variables) {
     $variables['messages'][$key] = $elements[$key];
   }
 }
+
+/**
+ * Implements hook_entity_predelete().
+ *
+ * Cleans up any references to the entity that is being deleted.
+ */
+function message_digest_entity_predelete(EntityInterface $entity) {
+  switch ($entity->getEntityTypeId()) {
+    case 'message':
+      Database::getConnection()
+        ->delete('message_digest')
+        ->condition('mid', $entity->id())
+        ->execute();
+      break;
+
+    case 'user':
+      Database::getConnection()
+        ->delete('message_digest')
+        ->condition('receiver', $entity->id())
+        ->execute();
+      break;
+  }
+}
diff --git a/message_digest.post_update.php b/message_digest.post_update.php
new file mode 100644
index 0000000..9230636
--- /dev/null
+++ b/message_digest.post_update.php
@@ -0,0 +1,52 @@
+<?php
+
+/**
+ * @file
+ * Post update functions for Message Digest.
+ */
+
+use Drupal\Core\Database\Database;
+
+/**
+ * Delete orphaned messages.
+ */
+function message_digest_post_update_delete_orphaned_messages() {
+  $connection = Database::getConnection();
+
+  // Retrieve a list of all references to messages.
+  $query = $connection->select('message_digest', 'md');
+  $query->fields('md', ['mid']);
+  $query->distinct();
+  $referenced_message_ids = $query->execute()->fetchCol();
+
+  // Retrieve a list of actual messages.
+  $query = \Drupal::entityQuery('message');
+  $existing_message_ids = $query->execute();
+
+  // Delete references to messages that no longer exist.
+  $orphaned_message_ids = array_diff($referenced_message_ids, $existing_message_ids);
+  if (!empty($orphaned_message_ids)) {
+    $connection->delete('message_digest')
+      ->condition('mid', $orphaned_message_ids, 'IN')
+      ->execute();
+  }
+
+  // Retrieve a list of all references to users.
+  $query = $connection->select('message_digest', 'md');
+  $query->fields('md', ['receiver']);
+  $query->distinct();
+  $referenced_user_ids = $query->execute()->fetchCol();
+
+  // Retrieve a list of actual users.
+  $query = \Drupal::entityQuery('user');
+  $existing_user_ids = $query->execute();
+
+  // Delete references to users that no longer exist.
+  $orphaned_user_ids = array_diff($referenced_user_ids, $existing_user_ids);
+  if (!empty($orphaned_user_ids)) {
+    $connection->delete('message_digest')
+      ->condition('receiver', $orphaned_user_ids, 'IN')
+      ->execute();
+  }
+
+}
diff --git a/src/DigestManager.php b/src/DigestManager.php
index fdc48a8..0421b25 100644
--- a/src/DigestManager.php
+++ b/src/DigestManager.php
@@ -151,13 +151,7 @@ class DigestManager implements DigestManagerInterface {
    * {@inheritdoc}
    */
   public function processDigests() {
-    foreach ($this->notifierManager->getDefinitions() as $plugin_id => $plugin_definition) {
-      $notifier = $this->notifierManager->createInstance($plugin_id, []);
-      if (!$notifier instanceof DigestInterface) {
-        // Only load the "Digest" notifiers and skip the rest.
-        continue;
-      }
-
+    foreach ($this->getNotifiers() as $notifier) {
       if ($notifier->processDigest()) {
         // Gather up all the messages into neat little digests and send 'em out.
         // It is up to each digest plugin to manage last sent time, etc.
@@ -168,7 +162,7 @@ class DigestManager implements DigestManagerInterface {
           // Queue each recipient digest for processing and sending.
           $data = [
             'uid' => $uid,
-            'notifier_id' => $plugin_id,
+            'notifier_id' => $notifier->getPluginId(),
             'end_time' => $end_time,
           ];
           $this->queue->createItem($data);
@@ -178,12 +172,36 @@ class DigestManager implements DigestManagerInterface {
     }
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function getNotifiers() {
+    $notifiers = [];
+
+    foreach ($this->notifierManager->getDefinitions() as $plugin_id => $plugin_definition) {
+      $notifier = $this->notifierManager->createInstance($plugin_id, []);
+      if (!$notifier instanceof DigestInterface) {
+        // Only load the "Digest" notifiers and skip the rest.
+        continue;
+      }
+      $notifiers[$notifier->getPluginId()] = $notifier;
+    }
+
+    return $notifiers;
+  }
+
   /**
    * {@inheritdoc}
    */
   public function processSingleUserDigest($account_id, $notifier_id, $end_time) {
+    /** @var \Drupal\user\UserInterface $account */
     $account = $this->entityTypeManager->getStorage('user')->load($account_id);
 
+    // If the user has been deleted, do not attempt to send any messages.
+    if (empty($account)) {
+      return;
+    }
+
     /** @var \Drupal\message_digest\Plugin\Notifier\DigestInterface $notifier */
     $notifier = $this->notifierManager->createInstance($notifier_id);
     assert($notifier instanceof DigestInterface, 'Notifier ID ' . $notifier_id . ' is not an instance of DigestInterface.');
@@ -192,8 +210,8 @@ class DigestManager implements DigestManagerInterface {
     $view_modes = array_combine($plugin_definition['viewModes'], $plugin_definition['viewModes']);
     $digests = $notifier->aggregate($account_id, $end_time);
     $max_mid = 0;
-    foreach ($digests as $entity_type) {
-      foreach ($entity_type as $entity_id => $message_ids) {
+    foreach ($digests as $entity_type => $entity_ids) {
+      foreach ($entity_ids as $entity_id => $message_ids) {
         $last_mid = max($message_ids);
         $max_mid = ($last_mid > $max_mid) ? $last_mid : $max_mid;
         // Load up the messages.
diff --git a/src/DigestManagerInterface.php b/src/DigestManagerInterface.php
index 7f4be23..3c0450f 100644
--- a/src/DigestManagerInterface.php
+++ b/src/DigestManagerInterface.php
@@ -9,6 +9,12 @@ interface DigestManagerInterface {
 
   /**
    * Cleanup old messages from the message_digest table.
+   *
+   * @deprecated
+   *   This method is deprecated and will be removed before Message Digest 8.2.0
+   *   is released. Entries in the message_digest table are cleaned up
+   *   automatically when messages or users are deleted so this is no longer
+   *   needed.
    */
   public function cleanupOldMessages();
 
@@ -31,4 +37,12 @@ interface DigestManagerInterface {
    */
   public function processSingleUserDigest($account_id, $notifier_id, $end_time);
 
+  /**
+   * Returns the Digest notifier plugins.
+   *
+   * @return \Drupal\message_digest\Plugin\Notifier\DigestInterface[]
+   *   An associative array of Digest notifier plugins, keyed by plugin ID.
+   */
+  public function getNotifiers();
+
 }
diff --git a/src/Plugin/Notifier/DigestBase.php b/src/Plugin/Notifier/DigestBase.php
index 67fceac..b9a0468 100644
--- a/src/Plugin/Notifier/DigestBase.php
+++ b/src/Plugin/Notifier/DigestBase.php
@@ -4,6 +4,7 @@ namespace Drupal\message_digest\Plugin\Notifier;
 
 use Drupal\Component\Datetime\TimeInterface;
 use Drupal\Core\Database\Connection;
+use Drupal\Core\Database\Database;
 use Drupal\Core\Entity\EntityTypeManagerInterface;
 use Drupal\Core\Logger\LoggerChannelInterface;
 use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
@@ -144,12 +145,9 @@ abstract class DigestBase extends MessageNotifierBase implements ContainerFactor
   }
 
   /**
-   * The interval to compile digests for.
-   *
-   * @return string
-   *   The interval. This should be compatible with `strtotime()`.
+   * {@inheritdoc}
    */
-  protected function getInterval() {
+  public function getInterval() {
     return $this->digestInterval;
   }
 
@@ -237,4 +235,37 @@ abstract class DigestBase extends MessageNotifierBase implements ContainerFactor
     $this->state->set($this->getPluginId() . '_last_run', $this->time->getRequestTime());
   }
 
+  /**
+   * Implements the magic __sleep() method.
+   */
+  public function __sleep() {
+    // Only serialize the local properties, ignoring all dependencies from the
+    // container. The database connection cannot be serialized and neither can
+    // other services like the state service and the entity type manager since
+    // they in turn also depend on an active database connection.
+    return [
+      'configuration',
+      'pluginId',
+      'pluginDefinition',
+      'message',
+      'digestInterval',
+    ];
+  }
+
+  /**
+   * Implements the magic __wakeup() method.
+   */
+  public function __wakeup() {
+    // Restore the database connection.
+    $this->connection = Database::getConnection();
+
+    // Restore the dependencies from the container.
+    $container = \Drupal::getContainer();
+    $this->entityTypeManager = $container->get('entity_type.manager');
+    $this->logger = $container->get('logger.channel.message_notify');
+    $this->renderer = $container->get('renderer');
+    $this->state = $container->get('state');
+    $this->time = $container->get('datetime.time');
+  }
+
 }
diff --git a/src/Plugin/Notifier/DigestInterface.php b/src/Plugin/Notifier/DigestInterface.php
index 70969fb..0725d0c 100644
--- a/src/Plugin/Notifier/DigestInterface.php
+++ b/src/Plugin/Notifier/DigestInterface.php
@@ -80,4 +80,12 @@ interface DigestInterface extends PluginInspectionInterface, DerivativeInspectio
    */
   public function setLastSent();
 
+  /**
+   * The interval to compile digests for.
+   *
+   * @return string
+   *   The interval. This should be compatible with `strtotime()`.
+   */
+  public function getInterval();
+
 }
diff --git a/src/Traits/MessageDigestTrait.php b/src/Traits/MessageDigestTrait.php
new file mode 100644
index 0000000..f53a8df
--- /dev/null
+++ b/src/Traits/MessageDigestTrait.php
@@ -0,0 +1,214 @@
+<?php
+
+namespace Drupal\message_digest\Traits;
+
+use Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException;
+use Drupal\message\MessageInterface;
+use Drupal\message_digest\Plugin\Notifier\DigestInterface;
+
+/**
+ * Methods useful for testing and integrating the Message Digest module.
+ */
+trait MessageDigestTrait {
+
+  /**
+   * Returns the total number of undelivered digest messages.
+   *
+   * @return int
+   *   The number of undelivered messages.
+   */
+  protected function countAllUndeliveredDigestMessages() {
+    $count = 0;
+    foreach ($this->getMessageDigestManager()->getNotifiers() as $notifier) {
+      foreach ($notifier->getRecipients() as $uid) {
+        $count += count($this->getUserMessagesByNotifier($notifier, $uid));
+      }
+    }
+    return $count;
+  }
+
+  /**
+   * Makes sure all notifiers will process messages at the next cron run.
+   */
+  protected function expireMessageDigestNotifiers() {
+    /** @var \Drupal\Core\State\StateInterface $state */
+    $state = \Drupal::service('state');
+    foreach ($this->getMessageDigestManager()->getNotifiers() as $notifier) {
+      $key = $notifier->getPluginId() . '_last_run';
+      $state->set($key, 0);
+    }
+  }
+
+  /**
+   * Makes sure all digest messages will be sent out at the next cron run.
+   */
+  protected function expireDigestMessages() {
+    // Make sure all unsent messages have a timestamp 1 day in the past. Any
+    // messages that are created during the test have a newer timestamp than the
+    // request of the bootstrapped Drupal instance, causing them to be ignored
+    // during sending.
+    /** @var \Drupal\Core\Database\Connection $database */
+    $database = \Drupal::service('database');
+    $database->update('message_digest')
+      ->fields(['timestamp' => time() - 24 * 60 * 60])
+      ->condition('sent', 0)
+      ->execute();
+  }
+
+  /**
+   * Returns the message rendered in the given view mode.
+   *
+   * @param \Drupal\message\MessageInterface $message
+   *   The message to render.
+   * @param string $view_mode
+   *   The view mode to use.
+   *
+   * @return string
+   *   The rendered message.
+   */
+  protected function getRenderedMessage(MessageInterface $message, $view_mode) {
+    $content = \Drupal::entityTypeManager()->getViewBuilder('message')->view($message, $view_mode);
+    return (string) \Drupal::service('renderer')->renderPlain($content);
+  }
+
+  /**
+   * Returns the messages that will be includes in the user's next digest.
+   *
+   * @param \Drupal\message_digest\Plugin\Notifier\DigestInterface $notifier
+   *   The digest notifier that is responsible for sending out the messages.
+   * @param int $uid
+   *   The ID of the user for which to return the messages.
+   * @param string $entity_type
+   *   Optional entity type. If supplied along with the $label property this can
+   *   be used to return only messages that refer to the given entity.
+   * @param string $label
+   *   Optional entity label. If supplied along with the $entity_type property
+   *   this can be used to return only messages that refer to the given entity.
+   *
+   * @return \Drupal\message\MessageInterface[]
+   *   The messages.
+   */
+  protected function getUserMessagesByNotifier(DigestInterface $notifier, $uid, $entity_type = NULL, $label = NULL) {
+    // We can't use `$notifier->getEndTime()` since the Behat request has been
+    // started earlier than the Drupal requests that created the digests.
+    $digests = $notifier->aggregate($uid, time());
+
+    // Optionally filter by entity.
+    if (!empty($entity_type) && !empty($label)) {
+      $entity = $this->getEntityByLabel($entity_type, $label);
+      $message_ids = !empty($digests[$entity_type][$entity->id()]) ? $digests[$entity_type][$entity->id()] : [];
+    }
+    else {
+      $message_ids = [];
+      foreach ($digests as $entity_type => $entities) {
+        foreach ($entities as $entity_id => $messages) {
+          $message_ids = array_merge($message_ids, $messages);
+        }
+      }
+    }
+    return $this->getMessages($message_ids);
+  }
+
+  /**
+   * Checks that the given view modes are supported by the given notifier.
+   *
+   * @param \Drupal\message_digest\Plugin\Notifier\DigestInterface $notifier
+   *   The message digest notifier to check.
+   * @param array $expected_view_modes
+   *   An array of view mode IDs to check.
+   *
+   * @throws \RuntimeException
+   *   Thrown when one or more of the given view mode IDs are not supported by
+   *   the given notifier.
+   */
+  protected function assertNotifierViewModes(DigestInterface $notifier, $expected_view_modes) {
+    $plugin_definition = $notifier->getPluginDefinition();
+    $actual_view_modes =  array_combine($plugin_definition['viewModes'], $plugin_definition['viewModes']);
+    if (!empty($diff = array_diff_key(array_flip($expected_view_modes), $actual_view_modes))) {
+      $missing_view_modes = implode(', ', array_keys($diff));
+      $id = $notifier->getPluginId();
+      throw new \RuntimeException("The following view modes are not supported by the '$id' digest notifier: '$missing_view_modes'.");
+    }
+  }
+
+  /**
+   * Returns the Message entities for the given IDs.
+   *
+   * @param int[] $message_ids
+   *   The message IDs.
+   *
+   * @return \Drupal\message\MessageInterface[]
+   *   The Message entities.
+   */
+  protected function getMessages(array $message_ids) {
+    $messages = [];
+    try {
+      $storage = \Drupal::entityTypeManager()->getStorage('message');
+      /** @var \Drupal\message\MessageInterface[] $messages */
+      $messages = $storage->loadMultiple($message_ids);
+    }
+    catch (InvalidPluginDefinitionException $e) {
+      // If the 'message' entity type does not exist for some reason then there
+      // are no messages.
+    }
+    return $messages;
+  }
+
+  /**
+   * Returns the message digest notifier for the given interval.
+   *
+   * @param string $interval_id
+   *   The ID of a message digest interval. Examples of predefined intervals are
+   *   'daily' and 'weekly'.
+   *
+   * @return \Drupal\message_digest\Plugin\Notifier\DigestInterface
+   *   The notifier.
+   *
+   * @throws \RuntimeException
+   *   Thrown when the requested notifier does not exist.
+   */
+  protected function getMessageDigestNotifierForInterval($interval_id) {
+    $digest_interval = $this->getMessageDigestInterval($interval_id)->getInterval();
+    $notifiers = $this->getMessageDigestManager()->getNotifiers();
+    foreach ($notifiers as $notifier) {
+      if ($notifier->getInterval() === $digest_interval) {
+        return $notifier;
+      }
+    }
+
+    throw new \RuntimeException("No digest notifier found for interval '$interval_id'.");
+  }
+
+  /**
+   * Returns the digest manager service.
+   *
+   * @return \Drupal\message_digest\DigestManagerInterface
+   *   The digest manager service.
+   */
+  protected function getMessageDigestManager() {
+    return \Drupal::service('message_digest.manager');
+  }
+
+  /**
+   * Returns the requested digest interval.
+   *
+   * @param string $id
+   *   The digest interval ID.
+   *
+   * @return \Drupal\message_digest\Entity\MessageDigestIntervalInterface
+   *   The digest interval entity.
+   */
+  protected function getMessageDigestInterval($id) {
+    try {
+      /** @var \Drupal\message_digest\Entity\MessageDigestIntervalInterface $entity */
+      $entity = \Drupal::entityTypeManager()
+        ->getStorage('message_digest_interval')
+        ->load($id);
+      return $entity;
+    }
+    catch (InvalidPluginDefinitionException $e) {
+      throw new \RuntimeException("Could not retrieve message digest interval '$id'.", 0, $e);
+    }
+  }
+
+}
diff --git a/tests/fixtures/update/message-digest-post-update-delete-orphaned-messages.php b/tests/fixtures/update/message-digest-post-update-delete-orphaned-messages.php
new file mode 100644
index 0000000..ef8be58
--- /dev/null
+++ b/tests/fixtures/update/message-digest-post-update-delete-orphaned-messages.php
@@ -0,0 +1,163 @@
+<?php
+
+/**
+ * @file
+ * Upgrade data for message_digest_post_update_delete_orphaned_messages().
+ *
+ * Contains database additions to drupal-8.bare.standard.php.gz for testing the
+ * upgrade path of message_digest_post_update_delete_orphaned_messages().
+ */
+
+use Drupal\Core\Database\Database;
+
+$connection = Database::getConnection();
+
+// User data.
+$connection->insert('users')
+  ->fields([
+    'uid',
+    'uuid',
+    'langcode',
+  ])
+  ->values([
+    'uid' => '3',
+    'uuid' => 'be49deb0-4b51-47b4-b5f3-355b473370a5',
+    'langcode' => 'en',
+  ])
+  ->execute();
+
+$connection->insert('users_field_data')
+  ->fields([
+    'uid',
+    'langcode',
+    'preferred_langcode',
+    'preferred_admin_langcode',
+    'name',
+    'pass',
+    'mail',
+    'timezone',
+    'status',
+    'created',
+    'changed',
+    'access',
+    'login',
+    'init',
+    'default_langcode',
+  ])
+  ->values([
+    'uid' => '3',
+    'langcode' => 'en',
+    'preferred_langcode' => 'en',
+    'preferred_admin_langcode' => NULL,
+    'name' => 'user-3',
+    'pass' => '$S$E4a4O.NdAXjqlYYciUSWTPJTsa2qODJPlosxyPHa4zG0BmcIPH.U',
+    'mail' => 'user-3@example.com',
+    'timezone' => 'Europe/Sofia',
+    'status' => '1',
+    'created' => '1456053421',
+    'changed' => '1457342212',
+    'access' => '1457552303',
+    'login' => '1457342212',
+    'init' => 'user-3@example.com',
+    'default_langcode' => '1',
+  ])
+  ->execute();
+
+// Messages.
+$connection->insert('message')
+  ->fields([
+    'mid',
+    'template',
+    'uuid',
+    'langcode',
+  ])
+  ->values([
+    'mid' => '2',
+    'template' => 'test_template',
+    'uuid' => '98660bfa-4d7c-4361-8880-5d40e74ce419',
+    'langcode' => 'en',
+  ])
+  ->values([
+    'mid' => '3',
+    'template' => 'test_template',
+    'uuid' => '46c4c879-08c0-4e23-b83b-aac56f6f4647',
+    'langcode' => 'en',
+  ])
+  ->execute();
+
+$connection->insert('message_field_data')
+  ->fields([
+    'mid',
+    'template',
+    'langcode',
+    'uid',
+    'created',
+    'arguments',
+    'default_langcode',
+  ])
+  ->values([
+    'mid' => '2',
+    'template' => 'test_template',
+    'langcode' => 'en',
+    'uid' => '700005',
+    'created' => '1516794322',
+    'arguments' => '',
+    'default_langcode' => '1',
+  ])
+  ->values([
+    'mid' => '3',
+    'template' => 'test_template',
+    'langcode' => 'en',
+    'uid' => '700006',
+    'created' => '1516794353',
+    'arguments' => '',
+    'default_langcode' => '1',
+  ])
+  ->execute();
+
+// Message digest data.
+$connection->insert('message_digest')
+  ->fields([
+    'id',
+    'mid',
+    'entity_type',
+    'entity_id',
+    'receiver',
+    'notifier',
+    'sent',
+    'timestamp',
+  ])
+  // An entry referencing an orphaned message.
+  ->values([
+    'id' => '1',
+    'mid' => '1',
+    'entity_type' => 'node',
+    'entity_id' => '1',
+    'receiver' => '1',
+    'notifier' => 'message_digest:daily',
+    'sent' => '0',
+    'timestamp' => '1516794322',
+  ])
+  // An entry referencing an orphaned user account.
+  ->values([
+    'id' => '2',
+    'mid' => '2',
+    'entity_type' => 'node',
+    'entity_id' => '2',
+    'receiver' => '2',
+    'notifier' => 'message_digest:daily',
+    'sent' => '0',
+    'timestamp' => '1516794322',
+  ])
+  // An entry referencing an existing message and user account.
+  ->values([
+    'id' => '3',
+    'mid' => '3',
+    'entity_type' => 'node',
+    'entity_id' => '3',
+    'receiver' => '3',
+    'notifier' => 'message_digest:daily',
+    'sent' => '0',
+    'timestamp' => '1516794322',
+  ])
+  ->execute();
diff --git a/tests/fixtures/update/message-digest-update-common.php b/tests/fixtures/update/message-digest-update-common.php
new file mode 100644
index 0000000..b5c0a0b
Binary files /dev/null and b/tests/fixtures/update/message-digest-update-common.php differ
diff --git a/tests/src/Functional/Update/ConfigEntityUpdateTest.php b/tests/src/Functional/Update/ConfigEntityUpdateTest.php
index 8e30ae0..a4a9da4 100644
--- a/tests/src/Functional/Update/ConfigEntityUpdateTest.php
+++ b/tests/src/Functional/Update/ConfigEntityUpdateTest.php
@@ -19,6 +19,7 @@ class ConfigEntityUpdateTest extends UpdatePathTestBase {
   protected function setDatabaseDumpFiles() {
     $this->databaseDumpFiles = [
       $this->root . '/core/modules/system/tests/fixtures/update/drupal-8.bare.standard.php.gz',
+      __DIR__ . '/../../../fixtures/update/message-digest-update-common.php',
       __DIR__ . '/../../../fixtures/update/message-digest-update-8101.php',
     ];
   }
diff --git a/tests/src/Functional/Update/DeleteOrphanedMessagesUpdateTest.php b/tests/src/Functional/Update/DeleteOrphanedMessagesUpdateTest.php
new file mode 100644
index 0000000..fe147d2
--- /dev/null
+++ b/tests/src/Functional/Update/DeleteOrphanedMessagesUpdateTest.php
@@ -0,0 +1,64 @@
+<?php
+
+namespace Drupal\Tests\message_digest\Functional\Update;
+
+use Drupal\FunctionalTests\Update\UpdatePathTestBase;
+
+/**
+ * Tests the post-update hook that cleans up orphaned messages.
+ *
+ * @see message_digest_post_update_delete_orphaned_messages()
+ *
+ * @group message_digest
+ */
+class DeleteOrphanedMessagesUpdateTest extends UpdatePathTestBase {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function setDatabaseDumpFiles() {
+    $this->databaseDumpFiles = [
+      $this->root . '/core/modules/system/tests/fixtures/update/drupal-8.bare.standard.php.gz',
+      __DIR__ . '/../../../fixtures/update/message-digest-update-common.php',
+      __DIR__ . '/../../../fixtures/update/message-digest-post-update-delete-orphaned-messages.php',
+    ];
+  }
+
+  /**
+   * Tests the post-update hook.
+   */
+  public function testUpdate() {
+    // There should be three rows in the message_digest table before executing
+    // the update.
+    $this->assertRowCount(3);
+
+    // One of the rows contains an orphaned reference to a deleted user, and
+    // another row an orphaned reference to a deleted message, so 1 row should
+    // remain after running the updates.
+    $this->runUpdates();
+    $this->assertRowCount(1);
+
+    // Check that the correct row remains. The correct row has the ID '3'.
+    $ids = \Drupal::database()->select('message_digest', 'md')
+      ->fields('md', ['id'])
+      ->execute()
+      ->fetchCol();
+    $id = reset($ids);
+    $this->assertEquals(3, $id);
+  }
+
+  /**
+   * Checks that the message_digest table contains the expected number of rows.
+   *
+   * @param int $expected_count
+   *   The expected number of rows.
+   */
+  protected function assertRowCount($expected_count) {
+    $actual_count = \Drupal::database()->select('message_digest', 'md')
+      ->countQuery()
+      ->execute()
+      ->fetchField();
+    $this->assertEquals($expected_count, $actual_count);
+  }
+
+}
diff --git a/tests/src/Kernel/DigestManagerTest.php b/tests/src/Kernel/DigestManagerTest.php
index 78fe7b2..7cce0db 100644
--- a/tests/src/Kernel/DigestManagerTest.php
+++ b/tests/src/Kernel/DigestManagerTest.php
@@ -17,9 +17,6 @@ class DigestManagerTest extends DigestTestBase {
    * @covers ::processDigests
    */
   public function testProcessDigests() {
-    /** @var \Drupal\message_digest\DigestManagerInterface $manager */
-    $manager = \Drupal::service('message_digest.manager');
-
     // Verify last sent time is not set.
     $this->assertEquals(0, $this->container->get('state')->get('message_digest:weekly_last_run', 0));
 
diff --git a/tests/src/Kernel/DigestTestBase.php b/tests/src/Kernel/DigestTestBase.php
index bd4b3be..9e2a426 100644
--- a/tests/src/Kernel/DigestTestBase.php
+++ b/tests/src/Kernel/DigestTestBase.php
@@ -44,6 +44,13 @@ abstract class DigestTestBase extends KernelTestBase {
    */
   protected $notifierSender;
 
+  /**
+   * The message digest manager.
+   *
+   * @var \Drupal\message_digest\DigestManagerInterface
+   */
+  protected $digestManager;
+
   /**
    * {@inheritdoc}
    */
@@ -51,10 +58,12 @@ abstract class DigestTestBase extends KernelTestBase {
     parent::setUp();
     $this->notifierManager = $this->container->get('plugin.message_notify.notifier.manager');
     $this->notifierSender = $this->container->get('message_notify.sender');
+    $this->digestManager = $this->container->get('message_digest.manager');
     $this->installEntitySchema('message');
     $this->installEntitySchema('user');
     $this->installSchema('message_digest', ['message_digest']);
     $this->installSchema('system', ['sequences']);
+    $this->installSchema('user', ['users_data']);
     $this->installConfig([
       'filter',
       'filter_test',
@@ -72,7 +81,7 @@ abstract class DigestTestBase extends KernelTestBase {
    */
   protected function sendDigests() {
     // Queue digests.
-    $this->container->get('message_digest.manager')->processDigests();
+    $this->digestManager->processDigests();
     // Run queue.
     $this->container->get('cron')->run();
   }
diff --git a/tests/src/Kernel/MessageDigestTest.php b/tests/src/Kernel/MessageDigestTest.php
index 30ba8c8..99a562a 100644
--- a/tests/src/Kernel/MessageDigestTest.php
+++ b/tests/src/Kernel/MessageDigestTest.php
@@ -31,21 +31,41 @@ class MessageDigestTest extends DigestTestBase {
 
   /**
    * Tests the notifier sending and delivery.
+   *
+   * @param bool $reference_entity
+   *   Whether or not an entity should be referenced in the message digest that
+   *   is being sent.
+   * @param string $expected_subject
+   *   The expected subject for the email that is being sent.
+   *
+   * @dataProvider providerTestNotifierDelivery
    */
-  public function testNotifierDelivery() {
+  public function testNotifierDelivery($reference_entity, $expected_subject) {
     // Set the site name, so we can check that it is used in the subject of the
     // digest e-mail.
     $this->config('system.site')->set('name', 'Test site')->save();
 
-    $template = $this->createMessageTemplate('foo', 'Foo', 'Foo, foo', []);
+    $template = $this->createMessageTemplate('foo', 'Foo', 'Foo, foo', ['Test message']);
     $dummy = Message::create(['template' => $template->id()]);
     /** @var \Drupal\message_digest\Plugin\Notifier\DigestInterface $digest_notifier */
     $digest_notifier = $this->notifierManager->createInstance('message_digest:daily', [], $dummy);
 
+    $configuration = [];
+    // If we are referencing an entity, create a test user and reference it in
+    // the message digest.
+    if ($reference_entity) {
+      $referenced_user = $this->createUser([], 'Test user');
+      $configuration = [
+        'entity_type' => 'user',
+        'entity_id' => $referenced_user->id(),
+      ];
+    }
+
+    // Create a recipient and send the message.
     $account = $this->createUser();
     $dummy->setOwner($account);
     $dummy->save();
-    $this->notifierSender->send($dummy, [], $digest_notifier->getPluginId());
+    $this->notifierSender->send($dummy, $configuration, $digest_notifier->getPluginId());
     $result = $this->container->get('database')
       ->select('message_digest', 'm')
       ->fields('m')
@@ -60,10 +80,8 @@ class MessageDigestTest extends DigestTestBase {
     // Now deliver the message.
     $this->sendDigests();
 
-    $this->assertMail('subject', 'Test site message digest', 'Expected email subject is set.');
-    // @todo Fix the rendering of the message body.
-    // @see https://www.drupal.org/node/2813383
-    // $this->assertMail('body', "foo bar\n", 'Expected email body is set.');
+    $this->assertMail('subject', $expected_subject, 'Expected email subject is set.');
+    $this->assertMail('body', "Test message\n\n", 'Expected email body is set.');
     $this->assertMail('id', 'message_digest_digest', 'Expected email key is set.');
     $this->assertMail('to', $account->getEmail(), 'Expected email recipient is set.');
 
@@ -76,6 +94,32 @@ class MessageDigestTest extends DigestTestBase {
     $this->assertTrue($this->container->get('state')->get('message_digest_test_message_digest_view_mode_alter', FALSE));
   }
 
+  /**
+   * Data provider for ::testNotifierDelivery().
+   *
+   * @return array
+   *   An array of test data, each test case an array with two elements:
+   *   - A boolean indicating whether or not an entity should be referenced.
+   *   - The expected subject of the message digest e-mail that is sent.
+   */
+  public function providerTestNotifierDelivery() {
+    return [
+      // Test case that does not reference an entity. In this case the site name
+      // should be mentioned in the message subject.
+      [
+        FALSE,
+        'Test site message digest',
+      ],
+      // Test case that references an entity. In this case the name of the
+      // entity should be mentioned in the message subject. We are using a user
+      // entity to test this case.
+      [
+        TRUE,
+        'Test user message digest',
+      ],
+    ];
+  }
+
   /**
    * Tests message aggregation.
    */
@@ -264,7 +308,7 @@ class MessageDigestTest extends DigestTestBase {
     foreach (range(1, 5) as $i) {
       $messages[$i]->delete();
     }
-    $this->container->get('message_digest.manager')->cleanupOldMessages();
+    $this->digestManager->cleanupOldMessages();
     $result = $this->container->get('database')->select('message_digest', 'md')
       ->fields('md')
       ->execute()
@@ -275,11 +319,59 @@ class MessageDigestTest extends DigestTestBase {
     }
   }
 
+  /**
+   * Tests that the message_digest table is cleaned up when deleting entities.
+   */
+  public function testOrphanedEntityReferences() {
+    $template = $this->createMessageTemplate('foo', 'Foo', 'Foo, foo', []);
+
+    // Create 3 test users and send 3 messages, one to each user.
+    $users = $messages = [];
+    for ($i = 0; $i < 3; $i++) {
+      $user = $this->createUser();
+
+      $message = Message::create(['template' => $template->id()]);
+      $message->setOwner($user);
+      $message->save();
+
+      $digest_notifier = $this->notifierManager->createInstance('message_digest:weekly', [], $message);
+      $this->notifierSender->send($message, [], $digest_notifier->getPluginId());
+
+      $users[$i] = $user;
+      $messages[$i] = $message;
+    }
+
+    // There should be 3 message digests.
+    $this->assertRowCount(3);
+
+    // Delete one of the messages and verify that the corresponding message
+    // digest is cleaned up.
+    $orphaned_message_id = $messages[0]->id();
+    $messages[0]->delete();
+    $this->assertRowCount(2);
+    foreach ($this->getAllMessageDigests() as $digest) {
+      if ($digest->mid == $orphaned_message_id) {
+        $this->fail('When a message is deleted its corresponding message digest is cleaned up.');
+      }
+    }
+
+    // Delete one of the users and verify that the corresponding message digest
+    // is cleaned up.
+    $orphaned_user_id = $users[1]->id();
+    $users[1]->delete();
+    $this->assertRowCount(1);
+    foreach ($this->getAllMessageDigests() as $digest) {
+      if ($digest->receiver == $orphaned_user_id) {
+        $this->fail('When a user is deleted its corresponding message digest is cleaned up.');
+      }
+    }
+  }
+
   /**
    * Tests the message digest manager processing.
    */
   public function testManagerProcessing() {
-    $this->container->get('message_digest.manager')->processDigests();
+    $this->digestManager->processDigests();
     $request_time = $this->container->get('datetime.time')->getRequestTime();
     $this->assertEquals($request_time, $this->container->get('state')->get('message_digest:daily_last_run'));
     $this->assertEquals($request_time, $this->container->get('state')->get('message_digest:weekly_last_run'));
@@ -433,4 +525,34 @@ class MessageDigestTest extends DigestTestBase {
     $this->assertEquals($expected, $email['body']);
   }
 
+  /**
+   * Returns all rows from the message_digest table.
+   *
+   * @return array
+   *   An array of all table rows, keyed by ID.
+   *
+   * @throws \Exception
+   *   Thrown when the database connection is not available on the container.
+   */
+  protected function getAllMessageDigests() {
+    return $this->container->get('database')
+      ->select('message_digest', 'm')
+      ->fields('m')
+      ->execute()
+      ->fetchAllAssoc('id');
+  }
+
+  /**
+   * Checks that the message_digest table contains the expected number of rows.
+   *
+   * @param int $expected_count
+   *   The expected number of rows.
+   *
+   * @throws \Exception
+   *   Thrown when the database connection is not available on the container.
+   */
+  protected function assertRowCount($expected_count) {
+    $this->assertEquals($expected_count, count($this->getAllMessageDigests()));
+  }
+
 }
